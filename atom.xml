<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程式人蔘</title>
  <subtitle>舊版blog http://irongateinfo.blogspot.tw</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://humorless.github.io/"/>
  <updated>2017-07-23T04:43:18.497Z</updated>
  <id>http://humorless.github.io/</id>
  
  <author>
    <name>Laurence Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ttl</title>
    <link href="http://humorless.github.io/2017/07/23/ttl/"/>
    <id>http://humorless.github.io/2017/07/23/ttl/</id>
    <published>2017-07-23T04:17:39.000Z</published>
    <updated>2017-07-23T04:43:18.497Z</updated>
    
    <content type="html"><![CDATA[<p>公司的程式碼裡，有幾張 mysql 表格的 schema 長成這樣子： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable (</div><div class="line">  exist boolean DEFAULT NULL,</div><div class="line">  updated datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,</div><div class="line">  ...</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>而該張 table 對應的更新 SQL 語句，最後也會有下列的這一段：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UPDATE mytable SET exist = 0, updated = FROM_UNIXTIME(%d) WHERE exist = 1 AND updated &lt;= DATE_SUB(NOW(), INTERVAL 10 MINUTE);</div></pre></td></tr></table></figure></p>
<p>對應的語意是這樣子：『如果這張表格 (table) 裡的某個列 (row) ，已經整整十分鐘沒有任何的寫入或是更新的話，就將這個列的屬性設定為不存在 (exist = 0)』</p>
<p>會需要用這種寫法：因為這張表格 (table) ，它儲存的資訊是一種「快取」 (cache) 性質的資訊，任何的列 (row) 如果超過十分鐘沒有任何更新或是寫入的話，表示這個列在原始的資料來源已經不存在了。換言之，這個寫法可以算是一種 hack ，因為 mysql 裡的 row 並沒有 time to live (ttl) 的語法。遇到要表達 ttl 語意的情況時，就會需要多幾個欄位和對應的 SQL 語句，才能表現。另一方面， Redis 和 mongoDB 因為設計時，本來就有考慮主要的用途之一要做為 cache 使用，自然也就會提供 ttl 的語法了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的程式碼裡，有幾張 mysql 表格的 schema 長成這樣子： 
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cla
    
    </summary>
    
    
      <category term="SQL" scheme="http://humorless.github.io/tags/SQL/"/>
    
      <category term="ttl" scheme="http://humorless.github.io/tags/ttl/"/>
    
      <category term="Redis" scheme="http://humorless.github.io/tags/Redis/"/>
    
      <category term="mongoDB" scheme="http://humorless.github.io/tags/mongoDB/"/>
    
      <category term="cache" scheme="http://humorless.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>dependency injection with Clojure</title>
    <link href="http://humorless.github.io/2017/07/12/dependency-injection/"/>
    <id>http://humorless.github.io/2017/07/12/dependency-injection/</id>
    <published>2017-07-12T15:44:46.000Z</published>
    <updated>2017-07-12T16:08:56.859Z</updated>
    
    <content type="html"><![CDATA[<p>寫 clojure 的時候，雖然套用了 REPL-driven development 的開發方式，已經相對可以讓大多數的函數很快地做過測試。但是，隨著要開發的專案愈來愈大，還是一樣需要用標準的寫法來寫單元測試 (unit test) 。有一個非正規的統計，如果是 Ruby on Rail 的專案，一般而言，90% 的函數都是有副作用的。然而， clojure 語言的專案，往往只有 40% 的函數帶有副作用。</p>
<p>即使是寫 clojure 語言，還是會遇到有 side effect 的函數，那比較好的寫法是怎麼樣呢？</p>
<a id="more"></a>
<p>我查了一下 stackoverflow 之後，很快就找到了一個很好用的函數 <code>with-redefs</code> 。 stackoverflow 上的答案大意如下： 由於 clojure 語言有 Dynamic binding 的特性，使用 <code>with-redefs</code> 就可以實現同樣的語意了。</p>
<p>我試了一下，還真的管用，範例如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">deftest</span> platform-contact-test</div><div class="line">  (<span class="name">testing</span> <span class="string">"platform-contact"</span></div><div class="line">    <span class="comment">; use the DI technique to test the function platform-contact</span></div><div class="line">    (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">170</span></div><div class="line">           (<span class="name">with-redefs</span> [get-platform-contact (<span class="name"><span class="builtin-name">fn</span></span> [_] (<span class="name"><span class="builtin-name">slurp</span></span> <span class="string">"./resources/contact_data.txt"</span>))]</div><div class="line">             (<span class="name"><span class="builtin-name">count</span></span> (<span class="name">platform-contact</span> (<span class="name">temp-platform-all</span>))))))))</div></pre></td></tr></table></figure>
<p>在這個範例中，原本的 <code>get-platform-contact</code> 函數是一個有副作用的函數，它會被 <code>platform-contact</code> 函數呼叫。 <code>get-platform-contact</code> 函數會發出一個 http request ，並且傳回遠端 server 上的資料，所以如果沒有加以代換，單元測試就會非常慢。用了 <code>with-redefs</code> 之後，就可以輕易地將 <code>get-platform-contact</code> 代換成一個會傳回固定檔案資料的函數，如此就可以執行快速的單元測試了。</p>
<p>對於 clojure 這種先進的特性， stackoverflow 上有一句評論： Needing a framework for DI is really just compensating for a lack of sufficient features in the language itself.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寫 clojure 的時候，雖然套用了 REPL-driven development 的開發方式，已經相對可以讓大多數的函數很快地做過測試。但是，隨著要開發的專案愈來愈大，還是一樣需要用標準的寫法來寫單元測試 (unit test) 。有一個非正規的統計，如果是 Ruby on Rail 的專案，一般而言，90% 的函數都是有副作用的。然而， clojure 語言的專案，往往只有 40% 的函數帶有副作用。&lt;/p&gt;
&lt;p&gt;即使是寫 clojure 語言，還是會遇到有 side effect 的函數，那比較好的寫法是怎麼樣呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="unit test" scheme="http://humorless.github.io/tags/unit-test/"/>
    
      <category term="dependency-injection" scheme="http://humorless.github.io/tags/dependency-injection/"/>
    
      <category term="clojure" scheme="http://humorless.github.io/tags/clojure/"/>
    
  </entry>
  
  <entry>
    <title>insert</title>
    <link href="http://humorless.github.io/2017/06/03/insert/"/>
    <id>http://humorless.github.io/2017/06/03/insert/</id>
    <published>2017-06-02T21:03:24.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>同事為了快速開發，讀寫資料庫的程式碼並沒有多加考慮「資料庫」的特性，而是直接把資料庫當作 memory 來操作。這樣子的寫法，在資料量少的時候還好，資料量大的時候，就需要重構了。這段程式碼處理的問題是： 有一張 table ，有 4000 多個 rows 。每一段時間，就會得到大部分相同但是少部分不同的資料，要寫入這張表。相同的 row 要更新、不存在的 row 要插入。原始的寫法則是：「對於要更新的資料的每一筆，用它的 primary key ，也就是 <code>hostname</code> 這個 column 去 query 這張 table ，如果存在就更新，如果不存在就插入。」</p>
<a id="more"></a>
<h2 id="重構的想法"><a href="#重構的想法" class="headerlink" title="重構的想法"></a>重構的想法</h2><p>原始的作法造成了效能的瓶頸。改進的方式則是要依據幾個重要的想法：</p>
<ol>
<li>因為 application server 和 database server 之間有透過網路傳輸，所以「要更新的資料」，應該要儘量批次地送到 database server 。而不是一個一個 row 來傳送。</li>
<li>對於資料的運算，可以發生在 application server ，也可以發生在 database server。如果運算可以利用 SQL 語言來描述的話，就可以發生在 database server，也就可以先把資料送到 database 再做運算。</li>
</ol>
<p>我查到的資料裡，還有發現 MySQL 為了這一類的問題，還有一個專用的指令 <code>insert on duplicate key update</code> ，不過，由於我的資料表有 auto increment key ，我就選擇用 temp table 的作法。</p>
<h2 id="重構的程式碼"><a href="#重構的程式碼" class="headerlink" title="重構的程式碼"></a>重構的程式碼</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># 準備全新的 temporary table </div><div class="line">DROP TEMPORARY TABLE IF EXISTS temp;</div><div class="line">CREATE TEMPORARY TABLE temp LIKE hosts;</div><div class="line"></div><div class="line"># 將資料從「外部」填入 temp 表之中</div><div class="line"># 利用迴圈來建構 SQL 的 values part。</div><div class="line"># 需要注意 mysql max_allowed_packet 的常數。</div><div class="line">INSERT INTO temp</div><div class="line">(hostname, exist, activate, platform, platforms, idc, ip, isp, province, city, updated)</div><div class="line">       VALUES    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW());</div><div class="line"></div><div class="line"># 開始交易</div><div class="line">BEGIN;</div><div class="line"></div><div class="line"># 利用 inner join 找出有重複的 row，做 update 的操作。</div><div class="line">UPDATE hosts</div><div class="line">INNER JOIN temp</div><div class="line">ON   hosts.hostname =   temp.hostname</div><div class="line">SET hosts.exist = 1, hosts.activate = temp.activate, hosts.platform = temp.platform,</div><div class="line">    hosts.platforms = temp.platforms, hosts.idc = temp.idc, hosts.ip = temp.ip,</div><div class="line">    hosts.isp = temp.isp, hosts.province = temp.province, hosts.city = temp.city,</div><div class="line">    hosts.updated = temp.updated;</div><div class="line"></div><div class="line"># 利用 anti join 找出沒有重複出現的 row ，做 insert 的操作。</div><div class="line">INSERT INTO hosts(hostname, exist, activate, platform, platforms, idc, ip, isp, province, city, updated)</div><div class="line">SELECT temp.hostname, temp.exist, temp.activate, temp.platform, temp.platforms, temp.idc,</div><div class="line">       temp.ip, temp.isp, temp.province, temp.city, temp.updated</div><div class="line">FROM temp LEFT JOIN hosts</div><div class="line">ON  temp.hostname = hosts.hostname</div><div class="line">WHERE hosts.hostname IS NULL;</div><div class="line"></div><div class="line"># 結束交易</div><div class="line">COMMIT;</div><div class="line"></div><div class="line">DROP TEMPORARY TABLE temp;</div></pre></td></tr></table></figure>
<h2 id="安全性議題"><a href="#安全性議題" class="headerlink" title="安全性議題"></a>安全性議題</h2><p>當我把重構完成之後，就請同事幫我做 code review 。很快就找到了一個很大的問題，沒有考慮 security 。因為來源的資料是系統外的，有可能會有 SQL injection 。所以資料在插入資料表之前，應該要做 prepared statement ，才能確保安全性。</p>
<h2 id="實際效能測試"><a href="#實際效能測試" class="headerlink" title="實際效能測試"></a>實際效能測試</h2><p>做效能測試之後，發現有兩種解法，效能都是可以接受的。</p>
<ol>
<li>在插入大量的資料進入 temp table 時，使用 multiple insert 的語法。只用一個 SQL 指令就完成插入。(當然資料要先做字元的逸脫處理。)　用這樣子的作法的話，要考慮 4000 個 rows 的資料一次送到 database server 時， mysql 的 <code>max_allowed_packet</code> 常數是否夠大。</li>
<li>在插入大量的資料進入 temp table 時，逐條插入，但是使用 prepared statement 。這樣子的效能會略慢一些些，但是基本上也是夠快的。</li>
</ol>
<h2 id="除錯與驗証"><a href="#除錯與驗証" class="headerlink" title="除錯與驗証"></a>除錯與驗証</h2><p>開發的過程中，由於使用了 temp table ，而 MySQL 的 temp table 是只屬於 session 的。此外，MySQL 又會做 connection pooling ，所以開發的過程中，一度遇到「 temp table 不存在」的錯誤訊息，怎麼看都看不出 SQL 哪裡出錯，結果原來是因為 connection pooling 的關系，不同的 connection 無法共享 temp table 。 </p>
<p>由於有 connection pooling ，所以還是得要看 mysql general log 才能確定 connection 的 id 是否正確。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># in mysql, set these two parameters to show general log</span></div><div class="line">SET GLOBAL general_log = <span class="string">'ON'</span>;</div><div class="line">SET GLOBAL general_log_file = <span class="string">'/var/log/mysql/general.log'</span>;</div><div class="line"></div><div class="line"><span class="comment"># in shell, execute it. </span></div><div class="line">docker <span class="built_in">exec</span> -t <span class="variable">$MYSQL_docker_name</span> tail -f /var/<span class="built_in">log</span>/mysql/general.log &gt; mysql.log</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同事為了快速開發，讀寫資料庫的程式碼並沒有多加考慮「資料庫」的特性，而是直接把資料庫當作 memory 來操作。這樣子的寫法，在資料量少的時候還好，資料量大的時候，就需要重構了。這段程式碼處理的問題是： 有一張 table ，有 4000 多個 rows 。每一段時間，就會得到大部分相同但是少部分不同的資料，要寫入這張表。相同的 row 要更新、不存在的 row 要插入。原始的寫法則是：「對於要更新的資料的每一筆，用它的 primary key ，也就是 &lt;code&gt;hostname&lt;/code&gt; 這個 column 去 query 這張 table ，如果存在就更新，如果不存在就插入。」&lt;/p&gt;
    
    </summary>
    
    
      <category term="temp table" scheme="http://humorless.github.io/tags/temp-table/"/>
    
      <category term="insert on duplicate key update" scheme="http://humorless.github.io/tags/insert-on-duplicate-key-update/"/>
    
      <category term="SQL" scheme="http://humorless.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>message queue</title>
    <link href="http://humorless.github.io/2017/06/03/queue/"/>
    <id>http://humorless.github.io/2017/06/03/queue/</id>
    <published>2017-06-02T20:08:31.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>message queue 對我來說，一直都覺得它是一個很抽象，很難完整地理解其重要性的組件。看網路上找到的文章，也往往是用文字解釋，比方說 decoupling 之類的。終於我找到了一圖道盡千言萬言的解釋了。</p>
<a id="more"></a>
<p><img src="./datapipeline_complex.png" alt="使用前">
<img src="./datapipeline_simple.png" alt="使用後"></p>
<p>原始的圖，出自一篇 linkedin 講 kafka 的文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;message queue 對我來說，一直都覺得它是一個很抽象，很難完整地理解其重要性的組件。看網路上找到的文章，也往往是用文字解釋，比方說 decoupling 之類的。終於我找到了一圖道盡千言萬言的解釋了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="microservices" scheme="http://humorless.github.io/tags/microservices/"/>
    
      <category term="message queue" scheme="http://humorless.github.io/tags/message-queue/"/>
    
      <category term="distributed system" scheme="http://humorless.github.io/tags/distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>groupby</title>
    <link href="http://humorless.github.io/2017/05/21/groupby/"/>
    <id>http://humorless.github.io/2017/05/21/groupby/</id>
    <published>2017-05-20T22:56:40.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>一開始是我在寫 <a href="http://www.4clojure.com/problem/63" target="_blank" rel="external">4clojure</a> 的練習題的時候，寫到了一個題目，要重新實現 clojure 語言的 groupby 函數。我糾結了好一陣子，又查了不少資料，才勉強用 reduce 寫出來。然而，最近卻在工作中，用上了 groupby 。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">fn</span></span> f [k coll]</div><div class="line">  (<span class="name"><span class="builtin-name">reduce</span></span></div><div class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [c v]</div><div class="line">      (<span class="name"><span class="builtin-name">update-in</span></span> c [(<span class="name">k</span> v)] (<span class="name">fnil</span> conj []) v))</div><div class="line">    &#123;&#125; coll))</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>工作上遇到的問題是要重構同事寫的程式碼。程式碼做的事情是：「接受資料庫 dump 的 json 輸出，跑兩層很複雜的迴圈，對原始的資料做主鍵交換的處理，然後將資料存入 mysql 資料庫。」資料庫 dump 出來的 json 大概長成如下的樣子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  "result": [</div><div class="line">    &#123;</div><div class="line">      "platform": "c01.i01",</div><div class="line">      "ip_list": [</div><div class="line">        &#123;</div><div class="line">          "ip": "192.168.0.1",</div><div class="line">          "hostname": "ggyy6699"</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          "ip": "192.169.1.1",</div><div class="line">          "hostname:": "ggyy7700"</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      "platform": "c01.i05",</div><div class="line">      "ip_list": [</div><div class="line">        &#123;</div><div class="line">          "ip": "192.168.0.2",</div><div class="line">          "hostname": "ggkk8899"</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          "ip": "192.169.1.2",</div><div class="line">          "hostname:": "ggkk9900"</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>從這個 json 來看的話，<code>platform</code> 是主鍵 (primary key) 。而每一個 <code>platform</code> 下之下會有多個 <code>hostname</code> 。而程式碼做的事情是，先解析這個 json ，重新整理之後，讓 <code>hostname</code> 變成主鍵 (primary key) ，並且做成一行又一行的 row ，最後要存入關聯式資料庫。讓我感到困擾的地方是因為整理屬性與屬性之間複雜關系的程式碼，都塞在雙重迴圈裡頭，所以雙重迴圈就變得很複雜，而且這一段雙重迴圈的程式碼也無法複用，難以修改、難以維護。</p>
<p>轉換成用資料庫的觀點來看待這個問題之後，就得到了還不錯的解法：</p>
<ul>
<li>資料庫的 dump 輸出，本質上也是 join 兩張資料表的結果輸出，所以主鍵 (primary key) 本來就有可能交換。</li>
<li>既然要解析的資料是 join 之後的結果，所以有效的處理方式是這樣子：<ol>
<li>先將 json 的資料跑完簡單的雙重迴圈，雙重迴圈只做一件事，只將將資料做展開 (unfolding)，變成 join 完成的樣子。</li>
<li>python 的 <code>itertools.groupby</code> ，可以讓資料表 (table) 重新整理，產生出以任意的 column 做為主鍵 (primary key) 的新資料表 (table)。</li>
</ol>
</li>
</ul>
<p>程式碼如下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_h_platforms</span><span class="params">(res)</span>:</span></div><div class="line">    <span class="string">""" sample output</span></div><div class="line">    ctl-zj-061-130-028-019 ['c01.p02', 'c01.p02-kugou']</div><div class="line">    ctl-zj-061-130-028-020 ['c01.p02', 'c01.p02-kugou']</div><div class="line">    ctl-zj-061-130-028-022 ['c01.p02', 'c01.p02-kugou']</div><div class="line">    """</div><div class="line">    product = [(p[<span class="string">"platform"</span>], device[<span class="string">"hostname"</span>])</div><div class="line">               <span class="keyword">for</span> p <span class="keyword">in</span> res[<span class="string">"result"</span>] <span class="keyword">for</span> device <span class="keyword">in</span> p[<span class="string">"ip_list"</span>]]</div><div class="line">    data = sorted(product, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</div><div class="line">    <span class="keyword">for</span> key, grp <span class="keyword">in</span> itertools.groupby(data, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]):</div><div class="line">        print(key, list(map(<span class="keyword">lambda</span> x: x[<span class="number">0</span>], set(grp))))</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一開始是我在寫 &lt;a href=&quot;http://www.4clojure.com/problem/63&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4clojure&lt;/a&gt; 的練習題的時候，寫到了一個題目，要重新實現 clojure 語言的 groupby 函數。我糾結了好一陣子，又查了不少資料，才勉強用 reduce 寫出來。然而，最近卻在工作中，用上了 groupby 。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;fn&lt;/span&gt;&lt;/span&gt; f [k coll]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;reduce&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;fn&lt;/span&gt;&lt;/span&gt; [c v]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;update-in&lt;/span&gt;&lt;/span&gt; c [(&lt;span class=&quot;name&quot;&gt;k&lt;/span&gt; v)] (&lt;span class=&quot;name&quot;&gt;fnil&lt;/span&gt; conj []) v))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&amp;#125; coll))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="groupby database" scheme="http://humorless.github.io/tags/groupby-database/"/>
    
  </entry>
  
  <entry>
    <title>定義與實作</title>
    <link href="http://humorless.github.io/2017/04/28/complexity/"/>
    <id>http://humorless.github.io/2017/04/28/complexity/</id>
    <published>2017-04-28T04:57:46.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>緣起：最近在公司做的一個專案的內容，是要改善資料庫的效能。原本寫入資料庫的一段程式碼，因為最初寫的時候太暴力，完全套用 ORM 來硬寫，所以造成資料庫很大的負擔。也因此，我們決定要來重構這一部分的程式碼。</p>
<p>重構分成 3 個層面：</p>
<ol>
<li>SQL 語法的部分<br> 原本的 SQL 是用 ORM 硬做的，改成活用了 temp table 的語法後，效能就會改善許多。</li>
<li>移動程式碼到合適的 microservices<br> 本來週期性寫入資料庫的程式碼是放在 gateway 的模組。因為 gateway 模組需要有很快的反應時間 ，所以在 production 環境中， gateway 的模組有三個 instances ，也因此這段週期性寫入資料庫的程式變成要去考慮「平行寫入」的問題。其實這一段程式碼放錯了「模組」，應該要放在週期性執行的 cron 模組才對。放到全系統唯一的 cron 模組之後，就不需要再考慮「平行寫入」的問題。</li>
<li>加入合適的抽象層<br> 我們後來決定，要在再加入一層抽象層： restful API 用來包住資料庫的存取指令 。如此讓程式碼可以依賴於 restful API ，而不是直接依賴於某個特定的資料庫。</li>
</ol>
<a id="more"></a>
<p>這些重構，讓我想清楚了軟體工程中很重要的一個概念：「定義」與「實作」的分離。此處的『定義』，也可以解釋成「企業邏輯」，對應的複雜度可以用 essential complexity 來理解。換言之，定義層次的複雜度、定義層次的語意，是由需求來決定。此處的『實作』，則是指實現企業邏輯的各種可能的方案，對應的複雜度可以用 accidental complexity ，(當然我們一定儘可能去選擇 low accidental complexity 的方式來實現。) 一旦加入了 API 抽象層之後，日後的修改就會變得相對簡單。</p>
<p>比方說，如果是要從 gateway 模組移動 restful API 到 cron 模組，那我們測試的時候，只要確定 gateway 模組與 cron 模組使用 restful API 的方式是等價即可。 API 實現的細節則不會再有任何的改動。</p>
<p>另一種情況，如果需要做的改動是用 temp table 的語法取代舊有的 SQL 語法。這種改動完全藏在資料庫存取的 restful API 裡，所以我們之後驗証的時候，也就只需要對 restful API 做單元測試即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;緣起：最近在公司做的一個專案的內容，是要改善資料庫的效能。原本寫入資料庫的一段程式碼，因為最初寫的時候太暴力，完全套用 ORM 來硬寫，所以造成資料庫很大的負擔。也因此，我們決定要來重構這一部分的程式碼。&lt;/p&gt;
&lt;p&gt;重構分成 3 個層面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SQL 語法的部分&lt;br&gt; 原本的 SQL 是用 ORM 硬做的，改成活用了 temp table 的語法後，效能就會改善許多。&lt;/li&gt;
&lt;li&gt;移動程式碼到合適的 microservices&lt;br&gt; 本來週期性寫入資料庫的程式碼是放在 gateway 的模組。因為 gateway 模組需要有很快的反應時間 ，所以在 production 環境中， gateway 的模組有三個 instances ，也因此這段週期性寫入資料庫的程式變成要去考慮「平行寫入」的問題。其實這一段程式碼放錯了「模組」，應該要放在週期性執行的 cron 模組才對。放到全系統唯一的 cron 模組之後，就不需要再考慮「平行寫入」的問題。&lt;/li&gt;
&lt;li&gt;加入合適的抽象層&lt;br&gt; 我們後來決定，要在再加入一層抽象層： restful API 用來包住資料庫的存取指令 。如此讓程式碼可以依賴於 restful API ，而不是直接依賴於某個特定的資料庫。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="essential complexity" scheme="http://humorless.github.io/tags/essential-complexity/"/>
    
      <category term="accidental complexity" scheme="http://humorless.github.io/tags/accidental-complexity/"/>
    
  </entry>
  
  <entry>
    <title>程式語言「表達能力」的排序</title>
    <link href="http://humorless.github.io/2017/04/02/LOC/"/>
    <id>http://humorless.github.io/2017/04/02/LOC/</id>
    <published>2017-04-02T06:06:34.000Z</published>
    <updated>2017-07-12T15:37:55.837Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/" target="_blank" rel="external">原始的文章</a>來自於 RedMonk 網站。作者相當有創意地提出了統計的方法，來比較不同程式語言的表達能力。</p>
<p>有可能將不同的程式語言以「表達能力」或說是「效率」做個排序嗎？換言之，你能夠比較「透過某些程式語言來寫出某個概念有多容易」嗎？其中一種可以用來做出這種比較的方案是：<strong>每一次的原始碼提交 (commit) 有幾行原始碼的改變</strong>。這個方案可以提供一種觀點：一種程式語言可以讓你在同樣的行數空間內擁有多大的表達能力。因為在程式裡，臭蟲 (bug) 的數量是正比於程式碼的行數，而非這些程式碼表達了多少的概念，所以一種語言如果可以在同樣的行數內表達更多的概念就可以被認為是表達能力更強。</p>
<a id="more"></a>
<p><img src="/2017/04/02/LOC/expressiveness_weighted.png" alt="expressiveness weight">
第一張圖是用每一個 commit 裡的 LOC(lines of code) 的中位數來做排序</p>
<p><img src="/2017/04/02/LOC/expressiveness_iqr.png" alt="expressiveness iqr">
再考慮更深入一些，理想的程式語言應該是：</p>
<ol>
<li>夠簡單、容易學，而且大部分的開發者都可以高效率地使用它</li>
<li>在各式各樣的領域裡，都有接近相同的表達能力。</li>
</ol>
<p>所以，我們應該利用「每一個 commit 的 LOC 的四分位差 (百分之第25位和百分之第75位的差距)」來代表上述兩點的衡量標準。
第二張圖是用每一個 commit 裡的 LOC(lines of code) 的四分位差來做排序</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始的文章&lt;/a&gt;來自於 RedMonk 網站。作者相當有創意地提出了統計的方法，來比較不同程式語言的表達能力。&lt;/p&gt;
&lt;p&gt;有可能將不同的程式語言以「表達能力」或說是「效率」做個排序嗎？換言之，你能夠比較「透過某些程式語言來寫出某個概念有多容易」嗎？其中一種可以用來做出這種比較的方案是：&lt;strong&gt;每一次的原始碼提交 (commit) 有幾行原始碼的改變&lt;/strong&gt;。這個方案可以提供一種觀點：一種程式語言可以讓你在同樣的行數空間內擁有多大的表達能力。因為在程式裡，臭蟲 (bug) 的數量是正比於程式碼的行數，而非這些程式碼表達了多少的概念，所以一種語言如果可以在同樣的行數內表達更多的概念就可以被認為是表達能力更強。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming language expressiveness" scheme="http://humorless.github.io/tags/programming-language-expressiveness/"/>
    
  </entry>
  
  <entry>
    <title>Linux 小抄大全</title>
    <link href="http://humorless.github.io/2017/03/15/cheat/"/>
    <id>http://humorless.github.io/2017/03/15/cheat/</id>
    <published>2017-03-15T06:53:31.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>遇到指令不會用時，大家應該多少用過 cheatsheet 這個字當關鍵字吧，那如果直接安裝在電腦上呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 安裝 cheat 這個指令</div><div class="line">$sudo pip install cheat</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>用 cheat 查到的，常常都是該指令最經典的用法，比方說：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$cheat python</div><div class="line"># Desc: Python is a high-level programming language.</div><div class="line"></div><div class="line"># Basic example of server with python</div><div class="line"># Will start a Web Server in the current directory on port 8000</div><div class="line"># go to http://127.0.0.1:8000</div><div class="line"></div><div class="line"># Python v2.7</div><div class="line">python -m SimpleHTTPServer</div><div class="line"># Python 3</div><div class="line">python -m http.server 8000</div><div class="line"></div><div class="line"># SMTP-Server for debugging, messages will be discarded, and printed on stdout.</div><div class="line">python -m smtpd -n -c DebuggingServer localhost:1025</div><div class="line"></div><div class="line"># Pretty print a json</div><div class="line">python -mjson.tool</div></pre></td></tr></table></figure></p>
<p>什麼？你問「cheat 還有哪些用法？」
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cheat 它的功能是&quot;小抄&quot; ，既然不確定怎麼用的話，就先 cheat 自己吧。</div><div class="line">$cheat cheat</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到指令不會用時，大家應該多少用過 cheatsheet 這個字當關鍵字吧，那如果直接安裝在電腦上呢？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# 安裝 cheat 這個指令&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$sudo pip install cheat&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="cheat" scheme="http://humorless.github.io/tags/cheat/"/>
    
  </entry>
  
  <entry>
    <title>get latest commit hash from git repo</title>
    <link href="http://humorless.github.io/2017/03/15/get-latest-commit-hash-from-git-repo/"/>
    <id>http://humorless.github.io/2017/03/15/get-latest-commit-hash-from-git-repo/</id>
    <published>2017-03-15T05:37:22.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>「取得 git 遠端 repository 最新的 commit hash 」是我去年在公司做的工作的一小部分，由於當時太偷懶，沒有認真思考「依賴」的問題，我現在得重寫一些程式了。</p>
<p>去年的解法是這樣子，因為公司的 git repository 是放在 gitlab 上。我觀察了 gitlab 和 github 都有相似的 atom.xml 。不僅路徑一樣、輸出的格式也一樣，我就乾脆使用 gitlab 的 RSS 訂閱 API 來查 git 遠端 repository 最新的 commit hash 。然而， gitlab 在中國是常常連不上的。為了中國的問題，不得不把 git repository 換成是中國境內的 git 服務商，換成了 coding.net 的服務。然後，我就必須要重寫程式了，因為 coding.net 並沒有 RSS 訂閱的功能。</p>
<a id="more"></a>
<p>這個事情，仔細來思考，最根本的錯誤，就是我居然讓軟體的功能去依賴 gitlab 的一個 API 。所以一旦更換成別家的 git repository ，功能就得重新實現。理解了這個需求之後，我現在的重新實現，則是要讓這個「取得 git 遠端 repository 最新的 commit hash 」的功能，直接依賴於 git 指令。指令出乎意料的單純： <code>git ls-remote $GITURL</code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git ls-remote https://github.com/humorless/humorless.github.io.git</div><div class="line">cb7a2998571cb25693867afcb24a7331f597768e        HEAD</div><div class="line">1f7888215c04ac157edfeb6f30cff9eaebb774bd        refs/heads/backup</div><div class="line">cb7a2998571cb25693867afcb24a7331f597768e        refs/heads/master</div></pre></td></tr></table></figure></p>
<p>接下來的問題，就變成了我要如何讓後端的程式與 git 來做整合。公司的後端程式都是用 docker 來做布署，所以其實是可以在 docker 裡安裝 git 就可以使用 <code>git ls-remote</code>。那如果不安裝 git 行嗎？ 其實也是可以，一種是整合 git 的 library。或是更偷懶，直接用 <code>curl</code> 。( curl 的目標很容易取得，用 <code>tcpdump</code> 看一下 git ls-remote 執行過程即可。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -X GET https://github.com/humorless/humorless.github.io.git/info/refs?service=git-upload-pack</div><div class="line">001e# service=git-upload-pack</div><div class="line">000000edcb7a2998571cb25693867afcb24a7331f597768e HEADmulti_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2:2.6.5~peff-sha1dc-1707-ga50b0b4</div><div class="line">003f1f7888215c04ac157edfeb6f30cff9eaebb774bd refs/heads/backup</div><div class="line">003fcb7a2998571cb25693867afcb24a7331f597768e refs/heads/master</div><div class="line">0000</div></pre></td></tr></table></figure>
<p>curl 的解法自然可能有比較差的可攜性，最後我大概不會採用它。而這次栽在 gitlab RSS 訂閱的事也再一次地提醒了自己：「寫程式時，務必要想清楚解法的依賴」。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「取得 git 遠端 repository 最新的 commit hash 」是我去年在公司做的工作的一小部分，由於當時太偷懶，沒有認真思考「依賴」的問題，我現在得重寫一些程式了。&lt;/p&gt;
&lt;p&gt;去年的解法是這樣子，因為公司的 git repository 是放在 gitlab 上。我觀察了 gitlab 和 github 都有相似的 atom.xml 。不僅路徑一樣、輸出的格式也一樣，我就乾脆使用 gitlab 的 RSS 訂閱 API 來查 git 遠端 repository 最新的 commit hash 。然而， gitlab 在中國是常常連不上的。為了中國的問題，不得不把 git repository 換成是中國境內的 git 服務商，換成了 coding.net 的服務。然後，我就必須要重寫程式了，因為 coding.net 並沒有 RSS 訂閱的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://humorless.github.io/tags/git/"/>
    
      <category term="dependency" scheme="http://humorless.github.io/tags/dependency/"/>
    
  </entry>
  
  <entry>
    <title>pattern</title>
    <link href="http://humorless.github.io/2017/02/28/pattern/"/>
    <id>http://humorless.github.io/2017/02/28/pattern/</id>
    <published>2017-02-28T00:12:30.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="patterns-programming-with-abstactions-that-are-not-powerful-enough"><a href="#patterns-programming-with-abstactions-that-are-not-powerful-enough" class="headerlink" title="patterns = programming with abstactions that are not powerful enough"></a>patterns = programming with abstactions that are not powerful enough</h2><p>先來引述一下 Paul Graham 的句子
<blockquote><p>When I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I&#39;m using abstractions that aren&#39;t powerful enough.</p>
<footer><strong>Paul Graham</strong><cite>Revenge of the Nerds</cite></footer></blockquote></p>
<p>為了想出可以妥善解釋這段話的意思的 non-trivial 範例，其實我還想了滿久的。不料真的就在我學習 clojure 語言的過程之中找到了。這個範例是對某個 array 的每一個元素，做相同的運算處理：一個是循序處理、一個是平行處理。</p>
<a id="more"></a>
<h3 id="golang-的兩個版本"><a href="#golang-的兩個版本" class="headerlink" title="golang 的兩個版本"></a>golang 的兩個版本</h3><p>循序處理的版本
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">res := <span class="built_in">make</span>([]float, N);</div><div class="line"><span class="keyword">for</span> i,xi := <span class="keyword">range</span> data &#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>, xi float)</span></span> &#123;</div><div class="line">        res[i] = doSomething(i,xi);</div><div class="line">    &#125; (i, xi);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>平行處理的版本
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> empty &#123;&#125;</div><div class="line">...</div><div class="line">data := <span class="built_in">make</span>([]float, N);</div><div class="line">res := <span class="built_in">make</span>([]float, N);</div><div class="line">sem := <span class="built_in">make</span>(<span class="keyword">chan</span> empty, N);  <span class="comment">// semaphore pattern</span></div><div class="line">...</div><div class="line"><span class="keyword">for</span> i,xi := <span class="keyword">range</span> data &#123;</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>, xi float)</span></span> &#123;</div><div class="line">        res[i] = doSomething(i,xi);</div><div class="line">        sem &lt;- empty&#123;&#125;;</div><div class="line">    &#125; (i, xi);</div><div class="line">&#125;</div><div class="line"><span class="comment">// wait for goroutines to finish</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; ++i &#123; &lt;-sem &#125;</div></pre></td></tr></table></figure></p>
<h3 id="clojure-的兩個版本"><a href="#clojure-的兩個版本" class="headerlink" title="clojure 的兩個版本"></a>clojure 的兩個版本</h3><p>循序處理的版本
<figure class="highlight clj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> myfun [coll]</div><div class="line">  (<span class="name"><span class="builtin-name">map</span></span> doSomething coll))</div></pre></td></tr></table></figure></p>
<p>平行處理的版本</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> myfun [coll]</div><div class="line">  (<span class="name">pmap</span> doSomething coll))</div></pre></td></tr></table></figure>
<h3 id="抽象層次的差異"><a href="#抽象層次的差異" class="headerlink" title="抽象層次的差異"></a>抽象層次的差異</h3><p>比較這兩種語言寫的四段程式碼，很快可以發現，循序處理的範例都相當的簡單。然而，當換成平行處理的版本時， golang 的實作比 clojure 難多了。需要用 golang 的 channel 做出一個 semaphore 的 pattern 才能實現。而相較之下， clojure 把 map 換成 pmap 就可以了。由此可見， clojure 在這個例子之中，是一種足夠強的抽象層，可以輕易地去表達這個平行處理的語意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;patterns-programming-with-abstactions-that-are-not-powerful-enough&quot;&gt;&lt;a href=&quot;#patterns-programming-with-abstactions-that-are-not-powerful-enough&quot; class=&quot;headerlink&quot; title=&quot;patterns = programming with abstactions that are not powerful enough&quot;&gt;&lt;/a&gt;patterns = programming with abstactions that are not powerful enough&lt;/h2&gt;&lt;p&gt;先來引述一下 Paul Graham 的句子
&lt;blockquote&gt;&lt;p&gt;When I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I&amp;#39;m using abstractions that aren&amp;#39;t powerful enough.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Paul Graham&lt;/strong&gt;&lt;cite&gt;Revenge of the Nerds&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;為了想出可以妥善解釋這段話的意思的 non-trivial 範例，其實我還想了滿久的。不料真的就在我學習 clojure 語言的過程之中找到了。這個範例是對某個 array 的每一個元素，做相同的運算處理：一個是循序處理、一個是平行處理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="clojure" scheme="http://humorless.github.io/tags/clojure/"/>
    
      <category term="golang" scheme="http://humorless.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>migrate</title>
    <link href="http://humorless.github.io/2017/02/27/migrate/"/>
    <id>http://humorless.github.io/2017/02/27/migrate/</id>
    <published>2017-02-27T03:23:02.000Z</published>
    <updated>2017-07-12T15:37:55.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更換-blog-平台"><a href="#更換-blog-平台" class="headerlink" title="更換 blog 平台"></a>更換 blog 平台</h3><p>最近寫的技術文章愈來愈多都是有必要直接呈現程式碼。用 gist 的話，等於是把程式碼放在一個外部的空間來存放。總之，我覺得舊版的<a href="http://irongateinfo.blogspot.tw/" target="_blank" rel="external">技術blog</a> 用的 blogspot 雖然簡單好用，但是我是 blog 的重度使用者。我需要 markdown 來輔助。</p>
<p>候選的選項就是 octopress, hexo 。據說 node.js 的速度會比 Ruby 還快一些，那就用 <a href="https://hexo.io/zh-tw/" target="_blank" rel="external">hexo</a> 吧。</p>
<p>用 hexo 這種 blog 平台，最關鍵的問題就是備份了：我也找了一個用來處理 hexo 備份問題的<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="external">插件</a>，如此的話要在不同的電腦編輯也沒有問題了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;更換-blog-平台&quot;&gt;&lt;a href=&quot;#更換-blog-平台&quot; class=&quot;headerlink&quot; title=&quot;更換 blog 平台&quot;&gt;&lt;/a&gt;更換 blog 平台&lt;/h3&gt;&lt;p&gt;最近寫的技術文章愈來愈多都是有必要直接呈現程式碼。用 gist 的話，等於是
    
    </summary>
    
    
      <category term="diary" scheme="http://humorless.github.io/tags/diary/"/>
    
  </entry>
  
</feed>
